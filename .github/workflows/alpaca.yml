name: TradingView-Alpaca Bridge
'on':
  repository_dispatch:
    types:
      - trading-signal
  workflow_dispatch:

permissions:
  contents: write

jobs:
  place-order:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Process Trading Signal
        env:
          ALPACA_API_KEY: '${{ secrets.ALPACA_API_KEY }}'
          ALPACA_API_SECRET: '${{ secrets.ALPACA_API_SECRET }}'
          ALPACA_PAPER_TRADING: '${{ secrets.ALPACA_PAPER_TRADING }}'   # "true" or "false"
          SIGNAL_DATA: '${{ toJson(github.event.client_payload) }}'
          NOTIFICATIONS_ENABLED: 'true'
          NOTIFICATION_EMAIL: '${{ secrets.NOTIFICATION_EMAIL }}'
        run: |
          echo "Received trading signal"
          echo "Symbol: ${{ github.event.client_payload.symbol || 'N/A' }}"
          echo "Action: ${{ github.event.client_payload.action || 'N/A' }}"
          echo "Order size: ${{ github.event.client_payload.order_size || 'N/A' }}"
          echo "Notional: ${{ github.event.client_payload.notional || 'N/A' }}"
          echo "Price: ${{ github.event.client_payload.price || 'N/A' }}"
          echo "Alert message: ${{ github.event.client_payload.alert_message || 'N/A' }}"

          pip install alpaca-trade-api requests

          cat > trade.py << 'EOF'
          import os
          import json
          from datetime import datetime
          import alpaca_trade_api as tradeapi

          TRADE_LOG_FILE = 'trade_history.json'

          def log_trade(trade_info):
              try:
                  trades = []
                  if os.path.exists(TRADE_LOG_FILE):
                      with open(TRADE_LOG_FILE, 'r') as f:
                          try:
                              trades = json.load(f)
                          except json.JSONDecodeError:
                              trades = []
                  trades.append(trade_info)
                  with open(TRADE_LOG_FILE, 'w') as f:
                      json.dump(trades, f, indent=2)
                  print("Trade logged successfully!")
              except Exception as e:
                  print(f"Error logging trade: {e}")

          def _first_present(d, keys):
              for k in keys:
                  v = d.get(k)
                  if v is not None and str(v).strip() != "":
                      return v
              return None

          def _parse_float(v):
              if v is None:
                  return None
              try:
                  return float(str(v).strip())
              except (ValueError, TypeError):
                  return None

          def _normalize_symbol(sym: str) -> str:
              """
              Normalize common crypto variations:
              - BTCUSDT -> BTC/USD
              - BTCUSD  -> BTC/USD
              Leaves stock tickers unchanged (AAPL, TSLA, etc.)
              """
              s = sym.upper().replace(' ', '')
              if '/' in s:
                  return s
              if s.endswith('USDT'):
                  return s[:-4] + '/USD'
              if s.endswith('USD'):
                  return s[:-3] + '/USD'
              return s

          def place_order():
              try:
                  # Credentials
                  api_key = os.environ.get('ALPACA_API_KEY')
                  api_secret = os.environ.get('ALPACA_API_SECRET')
                  paper = os.environ.get('ALPACA_PAPER_TRADING', 'true').lower() == 'true'
                  if not api_key or not api_secret:
                      raise ValueError("Alpaca API credentials not provided")

                  # Payload
                  raw = os.environ.get('SIGNAL_DATA')
                  if not raw:
                      raise ValueError("No signal data provided")
                  signal = json.loads(raw)
                  print(f"Processing signal: {signal}")

                  # Required fields
                  symbol = _first_present(signal, ['symbol', 'ticker'])
                  if not symbol:
                      raise ValueError("No symbol provided in signal")
                  symbol = _normalize_symbol(symbol)

                  action = signal.get('action')
                  if not action or str(action).lower() not in ('buy', 'sell'):
                      raise ValueError("No valid action (buy/sell) provided in signal")
                  side = str(action).lower()

                  # Optional fields (qty / notional / price)
                  qty_raw = _first_present(signal, ['order_size', 'qty', 'quantity'])
                  qty_float = _parse_float(qty_raw)

                  notional_raw = _first_present(signal, ['notional', 'amount_usd', 'usd'])
                  notional = _parse_float(notional_raw)

                  limit_price_raw = _first_present(signal, ['price', 'limit_price'])
                  limit_price = _parse_float(limit_price_raw)

                  # Alpaca REST
                  base_url = 'https://paper-api.alpaca.markets' if paper else 'https://api.alpaca.markets'
                  print(f"Connecting to Alpaca API: {base_url}")
                  api = tradeapi.REST(api_key, api_secret, base_url, api_version='v2')

                  # Account log
                  acct = api.get_account()
                  print(f"Account status: {acct.status}; Portfolio value: {acct.portfolio_value}")

                  is_crypto = '/' in symbol  # simple but effective

                  # ---- VALIDATIONS per Alpaca rules ----
                  if notional is not None and limit_price is not None:
                      # Alpaca: notional cannot be used with limit/stop; only market
                      raise ValueError("Invalid combination: 'notional' cannot be sent with 'price'. Use qty for limit orders.")

                  if is_crypto and notional is not None:
                      # Alpaca: crypto does NOT support notional
                      raise ValueError("Invalid input: 'notional' is not supported for crypto. Use 'order_size'/'qty' instead.")

                  # ---- BUILD ORDER PARAMS ----
                  params = {
                      'symbol': symbol,
                      'side': side,
                      'time_in_force': 'gtc' if is_crypto else 'day'
                  }

                  # SIZE + TYPE decision tree
                  if notional is not None and notional > 0:
                      # STOCKS + NOTIONAL => MARKET only (fractional $ support)
                      params['notional'] = notional
                      params['type'] = 'market'
                      order_type = 'market'
                      print(f"[BRANCH] STOCK notional market order: ${notional}")
                  else:
                      # QTY path (stocks must be integer; crypto may be fractional)
                      if qty_float is None or qty_float <= 0:
                          qty_float = 1.0
                      params['qty'] = qty_float if is_crypto else int(qty_float)

                      if limit_price is not None and limit_price > 0:
                          # LIMIT order (works for both stocks and crypto)
                          params['type'] = 'limit'
                          params['limit_price'] = limit_price
                          order_type = 'limit'
                          print(f"[BRANCH] Qty-based LIMIT order @ {limit_price}")
                      else:
                          # MARKET order
                          params['type'] = 'market'
                          order_type = 'market'
                          print(f"[BRANCH] Qty-based MARKET order")

                  print(f"Submitting {order_type.upper()} {side} order with params: {params}")
                  order = api.submit_order(**params)
                  print(f"Order placed: id={order.id}, status={getattr(order, 'status', 'submitted')}")

                  trade_info = {
                      'timestamp': datetime.now().isoformat(),
                      'symbol': symbol,
                      'action': side,
                      'orderType': order_type,
                      'limitPrice': limit_price,
                      'qty': params.get('qty'),
                      'notional': params.get('notional'),
                      'timeInForce': params.get('time_in_force'),
                      'orderId': order.id,
                      'status': 'success'
                  }
                  log_trade(trade_info)
                  return trade_info

              except tradeapi.rest.APIError as e:
                  print(f"Alpaca API Error: {e}")
                  trade_info = {
                      'timestamp': datetime.now().isoformat(),
                      'symbol': symbol if 'symbol' in locals() else 'UNKNOWN',
                      'action': side if 'side' in locals() else 'UNKNOWN',
                      'orderType': 'unknown',
                      'limitPrice': limit_price if 'limit_price' in locals() else None,
                      'status': 'failed',
                      'error': str(e)
                  }
                  log_trade(trade_info)
                  return {"error": str(e)}
              except Exception as e:
                  print(f"Error placing order: {e}")
                  trade_info = {
                      'timestamp': datetime.now().isoformat(),
                      'symbol': symbol if 'symbol' in locals() else 'UNKNOWN',
                      'action': side if 'side' in locals() else 'UNKNOWN',
                      'orderType': 'unknown',
                      'limitPrice': limit_price if 'limit_price' in locals() else None,
                      'status': 'failed',
                      'error': str(e)
                  }
                  try:
                      log_trade(trade_info)
                  except Exception:
                      print("Error logging trade failure")
                  return {"error": str(e)}

          if __name__ == "__main__":
              result = place_order()
              print("Order process completed.")
          EOF

          python trade.py

          echo "Files in directory after script execution:"
          ls -la

      - name: Commit updated trade history
        run: |
          git config --global user.name "GitHub Action"
          git config --global user.email "action@github.com"
          if [ -f "trade_history.json" ]; then
            git add trade_history.json
            git commit -m "Update trade history [skip ci]" || echo "No changes to commit"
            git push || echo "Failed to push changes"
          else
            echo "trade_history.json not found"
          fi
